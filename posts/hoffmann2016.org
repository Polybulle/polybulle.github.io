#+TITLE:Notes de Lecture: Towards Automatic Resource Bound Analysis for OCaml
#+date:<2020-04-06 Mon>
#+AUTHOR: Hector Suzanne
* Introduction
Contribution : une analyse statique de
ressources pour les programmes OCaml /fonctionnels/, /d'ordre supérieur/, /avec
polymorphisme et type utilisateurs/. On obtient des polynômes multivariables
décrivant l'usage de ressources tel que le WCET, l'occupation mémoire ou la
consommation d'énergie. On utilise *AARA : Automatic Amortized Resource
Analysis*, un npuveau système de type et une nouvelle sémantique de la machine
virtuelle /ZINC/ d'OCaml.
On peut trouver des bornes asymptotique fortes pour des programmes
réels, comme les utilitaires standard sur les listes, l'algorithme de Dijkstra,
ou un client pour Amazon DynamoDB avec analyse statique du coût des accès au
nuage.

#+BEGIN_SRC ocaml
type ('a, 'b) ablist =
| Acons of 'a * ('a, 'b) list
| Bcons of 'b * ('a, 'b) list
| ABNil

let sort_the_as ablist = match ablist with
| Acons (a, tail) -> Acons (quicksort a, sort_the_as tail)
| Bcons (b, tail) -> Bcons (b          , sort_the_as tail)
| ABNil -> ABNil

(*
  RAML detecte les bornes suivantes:
    N = nombre de noeuds Acons de `ablist`
    K = max des tailles des arguments 'a des Acons
    L = N+K = taille de `ablist`
    Cout de sort_the_as:
      13*K*N^2 + 22*K*N + 13*L + 15*N + 11

  On retrouve bien la borne asymptotique en O(K^2 * N)
*)
#+END_SRC
* Survol
On extrait un AST typé du compilateur OCaml, puis on infère de nouveaux types
contenant des information de potentiel pour chaque expression. D'une déclaration
=t : T=, on obtient une autre définition =t : (T'; <qi...>))= ou =T'= est proche
de =T= (on précise les applications partielle/totales des fonctions aux sites
d'appels), et les =qi= sont des coefficients permettant de définir un potentiel
φ(t) = Σ qi * pi(t). Les polynômes =pi= sont définis pour chaque constructeurs
du type =T=. La sémantique du langage hôte induit des contraintes linéaires
entre les potentiels. Elles sont résolues par un solveur de programmation
linéaire externe lors d'un parcours de l'AST, comme on infère les types dans un
programme en produisant et résolvant des contraintes d'unification.

* Analyse de la programmation fonctionnelle
Il y a trois principale difficultés: Les fermeture/l'application partielle,
les arguments d'ordre supérieurs, et les effets de bords
*** Fermetures et curryfication
On prend comme exemple =val append : 'a list -> 'a list -> 'a list= de la
bibliothèque standard. L'appel =let foo = append xs= termine en temps constant,
et ne fait que créer une fermeture. Par contre, l'appel suivant =foo ys= renvoie
la liste =xs ++ ys= en temps et espace O(xs). Donc, l'usage de ressource de
=foo= ne dépend pas de son argument =ys=, mais est linéaire en la taille de la
valeur capturée =xs=. Hélas, il n'est pas suffisant de dé-curryfier =append=
pour retomber sur un cas plus simple: Un appel à =append= nécessite d'allouer
une paire pour les deux arguments. Dans le cas normal (=append= est curryfiée),
on prduit une fermeture si l'application est partielle, ou on appelle =append=
sans allocation si les deux arguments sont fournis.

On résout ce problème en raffinant les types des fonctions sur leurs sites
d'appels. Les applications partielles peuvent être saturées par eta-expansion,
et on change le type de la fonction de =a1 -> ... -> an -> t= en =[a1 ... an] ->
t=, qui indique la saturation de l'appel. L'analyse rend compte de
l'usage correct des ressource pour le second type, mais pas pour le premier.
En effet, l'algorithme est bien plus complexe si les valeurs capturées
dans les fermetures interviennent dans le calcul de complexité. L'analyse est
guidée par ce principe: /La complexité d'un appel de fonction ne doit dépendre
que de la taille de ses arguments/

On reconnaît la possibilité d'étendre le système pour gérer ces cas, mais cela a
un coût important de compléxité de l'analyse. On pourrait par exemple étendre le
raffinement des types avec des types dépendants.
*** Gestion de l'ordre supérieur
Dans le cas plus simple où on se limite à des estimations linéaires du coût, il est
possible de calculer la consommation de ressource en présence d'arguments
d'ordre supérieur en se ramenant à l'ordre 1. Mais c'est seulement possible quand les arguments sont analysables, et on doit entrelacer le typage et la génération de
contraintes. On préfère séparer les deux processus.

On peut alors analyser des fonctions même en l'absence d'information sur les
arguments: Il suffit de supposer leurs coût négligeable. L'analyse n'est alors
pas veine: On peut déterminer le coût propre de fonctions comme =map= et =fold=,
et l'analyse sert de preuve de terminaison. On peut en effet dire qu'une
fonction ayant un coût défini termine si et seulement si les appels aux
arguments terminent tous.

Dans les cas où la terminaison de la fonction dépend de propriétés des arguments
d'ordre supérieur, on ne peut pas conclure dans le cas général. Mais on peut
reprendre l'analyse dans les sites d'appels où ces arguments sont connus !
exemple:

#+BEGIN_SRC ocaml
(* Impossible de conclure ici *)
let iter f x = let y = f x in if y = 0 then () else iter f y

(* mais ici on peut spécialiser pour une valeur présice de `f`*)
let foo x = iter (fun z -> 0) x
#+END_SRC

*** Effets de bord
L'analyse vérifie que le coût du programme est indépendant des valeurs stockées
dans un état mutable quelconque. Dans le cas contraire, on peut peux pas
poursuivre. Il a été montré que l'analyse à base de polynômes peut être étendu
avec des potentiels pour les états mutables, mais le projet ne le fait pas, pour se
focaliser sur la contribution principale, l'analyse sur les programmes
fonctionnels.
L'analyse peut néanmoins interagir avec l'état mutable pour affiner ses
résultat. On peut par exemple, effectuer une analyse d'aliasing sur les
références à des fonctions: Si la référence en question ne peut prendre qu'un
nombre fini de valeurs (et qu'on peut le détecter,) alors on peut calculer un
coût au pire pour les appels à travers la référence.
Enfin, on peut étendre l'analyse aux programme lançant des exceptions en
annotant le type de l'exception et de ses arguments.
* Limites
Ne sont pas supportés:
- Les modules et les foncteurs
- Les enregistrements
- la POO d'OCaml
- la FFI
- le pattern matching imbriqué
- les arguments optionnels
- les structures mutables dans le cas général
- Les try/with en cas d'exception lancée
* Typage
** Core RAML
Après simplification de l'AST OCaml, on se ramène à un langage simple, où les
termes sont sous forme /let-share-normale/, ou l'on a remplacé le plus de sous
expressions possibles par les variables créées par let ou share (voir syntaxe).
Pour garantir que le programme transformé rend compte de la consommation du
programme en entrée, on peut marquer des constructions comme /gratuites/
(meta-syntaxe). Les constructions gratuites sont ignorés dans l'analyse. On
présente ici un langage réduit, sans types primitifs comme les tableaux, leurs
opérations, ou conditionelle.
*** Syntaxe
- Les classiques :: variables, application n-aire, abstraction, constructeurs,
  tuples, références, let, let rec de fonctions, pattern matching
- fail :: pour modéliser les exceptions
- tick(q ∈ ℚ) :: consommation de ressources
- share x as (y,z) in :: partage de valeurs
*** Définitons préalables
- K ∈ Syn :: les neouds de syntaxe
- M : Syn × ℕ -> ℚ :: Une /métrique de ressource/
- x ∈ Var :: les variables
- l ∈ Loc :: les adresses du tas
- H : Loc -> Val :: Un tas, de support fini
- V : Var -> Loc :: Un environnement, partiel
- S = · | l : S :: Une pile d'arguments
- null ∈ dom(H) :: Un pointeur nul tel que H(null) = null
*** Valeurs
- l :: position d'une valeur sur le tas
- (l1, ..., ln) :: tuples de valeur
- (λx.e, V) :: Fermeture (avec son jus)
- C l :: Application de constructeur à une valeur
*** Sémantique à grand pas
Le jugement de la sémantique est
#+BEGIN_SRC
S,V,H  ⊢_Μ e ⇓ w | (q,q')
#+END_SRC
qui s'entend par: Dans un environnement V, avec une pile S et un tas H,
l'expression e se réduit en un nombre d'étape en w, en induisant un coût (q,q')
selon la métrique de ressource M. Les réductions w sont soit
- (l, H') :: Une valeur de retour et un nouvel état
- ⊥ :: Echec (exceptions, accès de tableau invalide...)
- ○ :: Non-terminaison
** Consommation de ressource
Les consommation de ressources sont de la forme (q,q') où q est la "marée
haute", la quantité maximale de ressource dont on à besoin, et q' est la quantité
de ressource disponible après l'évaluation. La consommation est paramétrée par
une /métrique de ressources/ M, qui est une fonction qui à un noeud de la
syntaxe k et sa taille n associe un coût propre de la construction M(k,n) =
(q,q'). Les consommations forment un monoïde avec
- 0 = (0,0)
- (q,q')·(p,p') =
  - (q + p - q', p') si q' ≤ p
  - (q, p' + q' - p) si q' > p
La composition de deux consommation est la consommation de la séquence.
Dans le cas d'une analyse de WCET, les consommation sont (q, 0) car on le libère
pas de temps. En général, on note la consommation (q, 0) par q et (0, -q) par
-q. On peut alors dénoter la consommation des structures de données, par
exemple:

(e1,e2) a une consommation M(tuple,2)·(q1,q1')·(q2,q2')

