<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Notes de lectures: Closed-form Upper Bounds in Static Cost Analysis</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="../css/stylesheet.css" />
<script type="text/javascript">
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.cacheClassElem = elem.className;
         elem.cacheClassTarget = target.className;
         target.className = "code-highlighted";
         elem.className   = "code-highlighted";
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(elem.cacheClassElem)
         elem.className = elem.cacheClassElem;
       if(elem.cacheClassTarget)
         target.className = elem.cacheClassTarget;
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title">Notes de lectures: Closed-form Upper Bounds in Static Cost Analysis</h1>

<div id="outline-container-org04e1bd9" class="outline-2">
<h2 id="org04e1bd9">Introduction</h2>
<div class="outline-text-2" id="text-org04e1bd9">
<p>
On cherche à borner le coût en une certaine ressource d&rsquo;un programme <i>P</i> sur une
entrée arbitraire <i>x</i> sans pour autant avoir à déterminer le <i>x</i> qui réalise
cette borne ou avoir à calculer <i>P(x)</i>. Pour ce faire, on procède avec un
programme <i>P</i> et un <i>modèle de coût</i> donné. On produit dans un premier temps des
<i>relations de coûts (CR)</i> pour <i>P</i>. Ces relations décrivent le coût selon le
modèle du calcul de <i>P</i> en fonction de la <i>taille</i> de son entrée <i>x</i>.
</p>

<p>
Les CR sont un formalisme pertinent pour l&rsquo;analyse de coût pour les raisons
suivantes:
</p>
<ul class="org-ul">
<li>Elles sont agnostiques au langage et modèle de coût utilisés</li>
<li>Elles couvrent de nombreuses classes de complexités algorithmiques, et sont
donc polyvalentes</li>
<li>On peut y capturer des notions non-triviales de coûts, même à posteriori en
changeant le modèle.</li>
</ul>
<p>
La dynamique des CR est néanmoins non-triviale: l&rsquo;abstraction des données du
programme à leurs tailles crée une source de non-déterminisme: par exemple,
quand on branche selon une valeur du programme, et que les deux branches n&rsquo;ont
pas de coût égaux, notre analyse statique doit résoudre l&rsquo;ambiguïté.
</p>

<p>
Dans la littérature, on utilise souvent des <i>relations de récurrences</i> à la
place des relations de coûts. Cela à conduit à essayer de déléguer la recherche
de formes fermées des relations de coûts par des systèmes experts de calculs
symboliques (Mapple, Mathematica,etc.). Mais, nous le verrons, cette approche na
pas eue la succès escompté.
</p>

<p>
Notre nouvelle approche, basée sur l&rsquo;analyse statique d&rsquo;une sémantique de
programmation par contrainte des CR, est la première permettant d&rsquo;obtenir des
formes closes des CR automatiquement pour un grand nombre de programmes
impératifs représentatifs de ceux présent dans le monde réel.
</p>
</div>
</div>

<div id="outline-container-org6123181" class="outline-2">
<h2 id="org6123181">Relations de Coûts</h2>
<div class="outline-text-2" id="text-org6123181">
</div>
<div id="outline-container-org860ac2a" class="outline-3">
<h3 id="org860ac2a">Obtention</h3>
<div class="outline-text-3" id="text-org860ac2a">
<p>
On veut pouvoir inférer, depuis le code source d&rsquo;un programme impératif
structuré (avec <code>if</code>, <code>while</code>,&#x2026;) ou non-structuré (avec <code>goto</code>, <code>jump</code>) les
relations de tailles qui existent entre les données qu&rsquo;il manipule. On procède
en trois étapes:
</p>
<ol class="org-ol">
<li>On construit les <i>Control Flow Graph</i> du programme pour rendre les
récurrences explicites.</li>
<li>En utilisant l&rsquo;interprétation abstraite, on obtient des <i>relation de tailles</i>
entres les différents appels récursifs. Les relations obtenues sont
généralement linéaires (i.e. on travaille dans les domaine abstrait des
polyèdres convexes), mais on peut utiliser un autre formalisme à condition
d&rsquo;avoir un solveur adapté plus loin dans le traitement.</li>
<li>On interprète le programme dans le modèle de coût choisi, afin de générer les
relations de coûts en elles-mêmes.</li>
</ol>
</div>
</div>

<div id="outline-container-orge3ffb97" class="outline-3">
<h3 id="orge3ffb97">Syntaxe</h3>
<div class="outline-text-3" id="text-orge3ffb97">
<pre class="example">
r   ::= ℝ+
n   ::= ℕ
v   ::= Ζ
lin ::= v1*x1 + ... vn*xn
c   ::= lin &lt; lin | lin ≤ lin | lin = lin
φ   ::= c+

exp ::= r         | nat(lin)
      | exp + exp | exp * exp  | exp - r
      | exp ^ r   | log_n(exp) | n^exp
      | max( exp+ )

cost ::=  C(x1...xn) = exp + ∑(i=1...n) D_i(yi1...yim) where φ
CRS  ::= cost+
</pre>

<p>
On notera que dans <code>cost</code>, les variables de <code>exp</code> et <code>y1..ym</code> ne sont pas
<i>définies</i> grâce à <code>x1...xn</code>, mais seulement reliées à elles par les contraintes
présentes dans <code>φ</code>.
</p>
</div>
</div>

<div id="outline-container-orgd716394" class="outline-3">
<h3 id="orgd716394">Sémantique</h3>
<div class="outline-text-3" id="text-orgd716394">
<p>
La sémantique des <i>CRS</i> suit celle d&rsquo;un programme en progammation logique par
contrainte: Pour évaluer un <code>C(v1...vn)</code>, on procède par étape:
</p>
<ol class="org-ol">
<li>On choisie une des clauses du CRS qui a <code>C</code> en tête.</li>
<li>on instancie les variables <code>x1...xn, yi1...yim, vars(exp)</code> de manière à
satisfaire <code>φ</code>.</li>
<li>On calcule et accumule <code>exp</code> sous l&rsquo;instanciation précédente</li>
<li>On itère sur tout les <code>D_i</code></li>
</ol>
<p>
Quand on ne peut pas satisfaire <code>φ</code>, on a atteint un échec.
La sémantique est parallèle à celle d&rsquo;un programme Prolog.
</p>

<p>
On définit alors la sémantique d&rsquo;un CRS comme l&rsquo;ensemble de arbres d&rsquo;évaluations
qu&rsquo;il engendre. Le coût d&rsquo;un arbre est défini par induction, et le coût du CRS
l&rsquo;ensemble des coût que ses arbres d&rsquo;évaluation.
</p>

<p>
On note <code>Trees(C(v1...vn), S)</code> l&rsquo;ensemble des arbres de l&rsquo;évaluation de
<code>C(v1...vn)</code> dans le CRS <code>S</code>, et <code>Answer(C(v1...vn), S)</code> l&rsquo;ensemble des coûts
engendrés.
</p>
</div>
</div>

<div id="outline-container-org4fc1f70" class="outline-3">
<h3 id="org4fc1f70">Comparaison avec des RR</h3>
<div class="outline-text-3" id="text-org4fc1f70">
<dl class="org-dl">
<dt>Non-déterminisme</dt><dd>L&rsquo;abstraction des valeurs par leurs tailles rends les CR
<i>très</i> non-déterministes, même dans les cas ou le programme ne l&rsquo;est pas. Voir
par exemple la fonction <code>filter</code>.</dd>
<dt>Contraintes inexactes</dt><dd>Les arguments des appels récursifs des CR ne sont
liées aux arguments à la racine que par des relations imprécises. On peut
avoir à les tirer dans les ensembles infinis. Dans les RR, les arguments des
appels récursifs sont connus si on connaît les arguments de l&rsquo;appel précédent.</dd>
<dt>Arguments multiples</dt><dd><p>
Dans les RR, l&rsquo;argument décroît selon un ordre bien
fondé, ce qui garantie la terminaison: on parle de récurrence structurelle.
Dans les CR, l&rsquo;ordre bien-fondé peut exister sur une <i>relation de taille</i>
arbitraire.
</p>

<p>
Les deux premiers cas sont une source importante de non-déterminisme du
résultat. Les CR ne définissent pas des fonctions mais des relations entre les
tailles des arguments et la &ldquo;taille&rdquo; du calcul associé. De plus, les systèmes
experts de résolutions de récurrence ne peuvent généralement par inférer seuls
l&rsquo;argument décroissant de manière bien-fondé nécessaire à la résolution de la
récurrence. Ces systèmes ne sont pas adaptés à la mise en forme close de CR.
</p>

<p>
On pourrait, enfin essayer de simplifier les CR pour en retirer le
non-déterminisme. Hélas, les exemples réels simples montrent sans ambiguïté
qu&rsquo;il existe des CR non-déterministes dont la borne sup n&rsquo;est pas modélisable
par celle d&rsquo;une de ses sous-CR déterministe.
</p></dd>
</dl>
</div>
</div>
</div>

<div id="outline-container-org4ff0509" class="outline-2">
<h2 id="org4ff0509">Bornes Supérieures de Forme Fermées des Relations de Coûts</h2>
<div class="outline-text-2" id="text-org4ff0509">
<p>
On définit les <i>Bornes Supérieures de <code>C</code> de formes fermées dans un CRS</i> <code>S</code>
comme une fonction <code>f : Ζ^n -&gt; ℝ+</code> telle que:
</p>
<ul class="org-ul">
<li><code>f(x1...xn) = exp</code></li>
<li><code>∀ v1...vn, ∀r ∈ Answers(C(v1...vn), S), f(v1...vn) ≥ r</code></li>
</ul>
</div>

<div id="outline-container-orgc6ca4fe" class="outline-3">
<h3 id="orgc6ca4fe">Bornage du Nombre de Noeuds</h3>
</div>

<div id="outline-container-org3f01e52" class="outline-3">
<h3 id="org3f01e52">Bornage du Coût par Noeud</h3>
</div>

<div id="outline-container-org9a06fbb" class="outline-3">
<h3 id="org9a06fbb">Cas des Algorithmes <i>Diviser-pour-régner</i></h3>
</div>
</div>

<div id="outline-container-org6bf8c7b" class="outline-2">
<h2 id="org6bf8c7b">Mise en Forme de Récurrence Directe des Relations de Coûts</h2>
</div>

<div id="outline-container-org2e50fda" class="outline-2">
<h2 id="org2e50fda">Incomplétude de l&rsquo;Analyse de Coût</h2>
</div>

<div id="outline-container-org2b01864" class="outline-2">
<h2 id="org2b01864">Évaluation Expérimentale</h2>
</div>

<div id="outline-container-org7092800" class="outline-2">
<h2 id="org7092800">Travaux Connexes</h2>
</div>

<div id="outline-container-orgc04a0b2" class="outline-2">
<h2 id="orgc04a0b2">Conclusion</h2>
</div>
</div>
</body>
</html>
