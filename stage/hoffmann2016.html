<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="fr" xml:lang="fr">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Notes de Lectures: Towards Automatic Resource Bound Analysis for OCaml</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="../css/stylesheet.css" />
<script type="text/javascript">
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.cacheClassElem = elem.className;
         elem.cacheClassTarget = target.className;
         target.className = "code-highlighted";
         elem.className   = "code-highlighted";
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(elem.cacheClassElem)
         elem.className = elem.cacheClassElem;
       if(elem.cacheClassTarget)
         target.className = elem.cacheClassTarget;
     }
    /*]]>*///-->
// @license-end
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Notes de Lectures: Towards Automatic Resource Bound Analysis for OCaml</h1>
<div id="table-of-contents">
<h2>Table des matières</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgbd45aff">Introduction</a>
<ul>
<li><a href="#orgd66302f">Premier exemple</a></li>
</ul>
</li>
<li><a href="#org71b0e8a">Analyse de la programmation fonctionnelle</a>
<ul>
<li><a href="#org3a6610a">Fermetures et curryfication</a></li>
<li><a href="#org1ce1dd1">Gestion de l&rsquo;ordre supérieur</a></li>
<li><a href="#orged39d20">Effets de bord</a></li>
</ul>
</li>
<li><a href="#org2222241">Core RAML, première sémantique</a>
<ul>
<li><a href="#org761957e">Syntaxe</a></li>
<li><a href="#org2cc8f64">Définitions sémantique</a></li>
<li><a href="#orgfe7f258">Sémantique à grand pas</a></li>
</ul>
</li>
<li><a href="#org509632c">Système de type affine avec pile</a>
<ul>
<li><a href="#org251e564">Types des fonctions simple</a></li>
<li><a href="#org892fc37">Types inductifs simples</a></li>
<li><a href="#org84873f2">Partage et polymorphisme</a></li>
<li><a href="#org0835a7b">Jugements et dérivations</a></li>
</ul>
</li>
<li><a href="#orgb70d2af">Polynômes de ressources</a>
<ul>
<li><a href="#orgda58d15">Polynômes de base</a></li>
<li><a href="#orgcec2160">Polynômes de ressources d&rsquo;un type</a></li>
<li><a href="#org5d84025">Potentiel d&rsquo;un programme</a></li>
</ul>
</li>
<li><a href="#org87285a5">Typage de ressources</a>
<ul>
<li><a href="#org2600b9c">(Dé)-construction des termes</a></li>
<li><a href="#orgb0bf9d4">Partage</a></li>
<li><a href="#org4ade613">Sous-typage</a></li>
<li><a href="#org18387ac">Jugement</a></li>
<li><a href="#org3971182">Règles</a></li>
<li><a href="#orgc63fb02">Théorème: Cohérence</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
<img src="../seal.png" alt="seal.png" /> <a href="../index.html">Retour à l&rsquo;accueil</a>
</p>

<div id="outline-container-orgbd45aff" class="outline-2">
<h2 id="orgbd45aff">Introduction</h2>
<div class="outline-text-2" id="text-orgbd45aff">
<p>
On introduit une analyse statique de ressources pour les programmes OCaml
<i>fonctionnels</i>, <i>d&rsquo;ordre supérieur</i>, <i>avec polymorphisme</i> et <i>types
utilisateurs</i>. On obtient en résultat des polynômes multivariables décrivant
l&rsquo;usage de ressources tel que le temps d&rsquo;exécution au pire (WCET), l&rsquo;occupation
mémoire, la consommation d&rsquo;énergie ou encore le nombre d&rsquo;appel à une API. On
utilise un nouveau système de type et une nouvelle sémantique de la machine
virtuelle <i>ZINC</i> d&rsquo;OCaml. On peut trouver des bornes non-asymptotiques fortes
pour des programmes réels, comme les utilitaires de la bibliothèque standard sur
les listes, l&rsquo;algorithme de Dijkstra, ou un client pour Amazon DynamoDB, avec à
chaque fois les métriques pertinentes.
</p>
</div>

<div id="outline-container-orgd66302f" class="outline-3">
<h3 id="orgd66302f">Premier exemple</h3>
<div class="outline-text-3" id="text-orgd66302f">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">type</span> <span style="color: #9a7500;">('a, 'b) ablist</span> =
| <span style="color: #2a2a2a; background-color: #eeeeee;">Acons</span> <span style="color: #3b6ea8;">of</span> 'a * ('a, 'b) list
| <span style="color: #2a2a2a; background-color: #eeeeee;">Bcons</span> <span style="color: #3b6ea8;">of</span> 'b * ('a, 'b) list
| <span style="color: #2a2a2a; background-color: #eeeeee;">ABNil</span>

<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #29838d;">sort_the_as</span> <span style="color: #cb9aad;">the_arg</span> = <span style="color: #3b6ea8;">match</span> ablist <span style="color: #3b6ea8;">with</span>
| <span style="color: #2a2a2a; background-color: #eeeeee;">Acons</span> (a, tail) -&gt; <span style="color: #2a2a2a; background-color: #eeeeee;">Acons</span> (quicksort a, sort_the_as tail)
| <span style="color: #2a2a2a; background-color: #eeeeee;">Bcons</span> (b, tail) -&gt; <span style="color: #2a2a2a; background-color: #eeeeee;">Bcons</span> (b          , sort_the_as tail)
| <span style="color: #2a2a2a; background-color: #eeeeee;">ABNil</span> -&gt; ABNil
</pre>
</div>

<p>
Sur ce fragment de véritable code OCaml, RAML infère comme métriques pertinentes
</p>
<ul class="org-ul">
<li><code>N</code>, le nombre de noeuds Acons de <code>the_arg</code>,</li>
<li><code>K</code>, le maximum des tailles des arguments de type <code>'a</code> des Acons, et</li>
<li><code>L = N+K</code> la taille de <code>the_arg</code>,</li>
</ul>
<p>
et assigne le coût mémoire <code>13*K*N^2 + 22*K*N + 13*L + 15*N + 11</code> à la fonction
analysée, en terme d&rsquo;étape d&rsquo;évaluation dans la sémantique à grand pas de RAML.
</p>

<p>
Pour ce faire, on extrait un AST typé du compilateur OCaml, puis on infère de
nouveaux types contenant des information de potentiel pour chaque expression. A
partir d&rsquo;une déclaration <code>t : T</code>, on obtient une autre définition <code>t : (T';
&lt;q1…qn&gt;))</code> ou <code>T'</code> est proche de <code>T</code> (on y précise si les applications sont
partielle ou totales), et les <code>qi</code> sont des coefficients permettant de définir
un potentiel \(φ(t) = Σ q_{i}*p_{i}(t)\). Les polynômes \(p_{i}\) sont définis pour
chaque constructeurs du type <code>T</code>. Notre sémantique induit des contraintes
linéaires entre les potentiels. Elles sont résolues par un solveur de
programmation linéaire après un parcours de l&rsquo;AST qui collecte les contraintes
et détermine les objectifs.
</p>
</div>
</div>
</div>

<div id="outline-container-org71b0e8a" class="outline-2">
<h2 id="org71b0e8a">Analyse de la programmation fonctionnelle</h2>
<div class="outline-text-2" id="text-org71b0e8a">
<p>
On a distingué trois principales difficultés à l&rsquo;analyse de ressource:
l&rsquo;application partielle, les arguments d&rsquo;ordre supérieurs, et les effets de
bords
</p>
</div>

<div id="outline-container-org3a6610a" class="outline-3">
<h3 id="org3a6610a">Fermetures et curryfication</h3>
<div class="outline-text-3" id="text-org3a6610a">
<p>
On prend comme exemple <code>val append : 'a list -&gt; 'a list -&gt; 'a list</code> de la
bibliothèque standard. L&rsquo;appel <code>let foo = append xs</code> termine en temps constant,
et ne fait que créer une fermeture. Par contre, l&rsquo;appel <code>foo ys</code> renvoie la
liste <code>xs @ ys</code> en temps et espace \(O(xs)\). Donc, l&rsquo;usage de ressource de <code>foo</code>
ne dépend pas de son argument <code>ys</code>, mais est linéaire en la taille de la valeur
capturée <code>xs</code>. Hélas, il n&rsquo;est pas suffisant de dé-curryfier <code>append</code> pour
retomber sur un cas plus simple: Un appel à une version dé-curryfiée d&rsquo;<code>append</code>
nécessite d&rsquo;allouer une paire pour les deux arguments, alors que dans le cas
normal, on produit une fermeture si l&rsquo;application est partielle, et on appelle
<code>append</code> sans allocation si les deux arguments sont fournis.
</p>

<p>
On résout ce problème en raffinant les types des fonctions sur leurs sites
d&rsquo;appels. Les applications partielles peuvent être saturées par eta-expansion,
et on change le type de la fonction de <code>a1 -&gt; … -&gt; an -&gt; t</code> en <code>[a1 … an] -&gt;
t</code>, où l&rsquo;annotation <code>[…]</code> indique la saturation de l&rsquo;appel. L&rsquo;analyse peut
alors rendre compte de l&rsquo;usage correct des ressource dans le second cas. Hélas,
elle est bien plus complexe si les valeurs capturées dans les fermetures
interviennent dans le calcul de complexité. L&rsquo;analyse est donc limitée aux
appels annotés <code>[…]</code>. De cet exemple ressort le critère principal de
notre analyse:
</p>
<blockquote>
<p>
<i>La complexité d&rsquo;un appel de fonction ne doit dépendre que de la
taille de ses arguments.</i>
</p>
</blockquote>

<p>
On reconnaît la possibilité d&rsquo;étendre le système pour gérer les appels
non-saturés, mais cela aurait un coût important en terme de complexité. On
pourrait par exemple étendre le raffinement des types avec des types dépendants.
</p>
</div>
</div>

<div id="outline-container-org1ce1dd1" class="outline-3">
<h3 id="org1ce1dd1">Gestion de l&rsquo;ordre supérieur</h3>
<div class="outline-text-3" id="text-org1ce1dd1">
<p>
Dans le cas plus simple où on se limite à des estimations linéaires du coût, il
est possible de calculer la consommation de ressource en présence d&rsquo;arguments
d&rsquo;ordre supérieur en se ramenant à l&rsquo;ordre un. Mais c&rsquo;est seulement possible
quand les arguments sont eux-mêmes analysables, et on doit entrelacer le typage
et la génération de contraintes. On préfère séparer les deux processus.
</p>

<p>
On peut néanmoins analyser les fonctionelles en l&rsquo;absence d&rsquo;information sur
leurs arguments: Il suffit de supposer les coûts qu&rsquo;ils engendrent négligeables.
L&rsquo;analyse n&rsquo;est alors pas veine: On peut déterminer le coût propre de fonctions
comme <code>map</code> et <code>fold</code>, et l&rsquo;analyse sert aussi de preuve de terminaison. On peut
en effet dire qu&rsquo;une fonction d&rsquo;ordre supérieur ayant un coût défini termine si
et seulement si les appels à ces arguments terminent tous.
</p>

<p>
Dans les cas où la terminaison de la fonction dépend de propriétés des arguments
d&rsquo;ordre supérieur, on ne peut pas conclure dans le cas général. Mais on peut
reprendre l&rsquo;analyse dans les sites d&rsquo;appels où ces arguments sont connus, comme
dans le cas suivant:
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #b1b1b1;">(* </span><span style="color: #b1b1b1;">Impossible de conclure ici </span><span style="color: #b1b1b1;">*)</span>
<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #29838d;">iter</span> <span style="color: #cb9aad;">f</span> <span style="color: #cb9aad;">x</span> =
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #cb9aad;">y</span> = f x <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #3b6ea8;">if</span> y = <span style="color: #97365b; font-weight: bold;">0</span>
  <span style="color: #3b6ea8;">then</span> ()
  <span style="color: #3b6ea8;">else</span> iter f y

<span style="color: #b1b1b1;">(* </span><span style="color: #b1b1b1;">mais ici on peut sp&#233;cialiser pour une valeur pr&#233;sice de `f`</span><span style="color: #b1b1b1;">*)</span>
<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #29838d;">foo</span> <span style="color: #cb9aad;">x</span> = iter (<span style="color: #3b6ea8;">fun</span> <span style="color: #cb9aad;">z</span> -&gt; <span style="color: #97365b; font-weight: bold;">0</span>) x
</pre>
</div>
</div>
</div>

<div id="outline-container-orged39d20" class="outline-3">
<h3 id="orged39d20">Effets de bord</h3>
<div class="outline-text-3" id="text-orged39d20">
<p>
L&rsquo;analyse vérifie que le coût du programme est indépendant des valeurs stockées
dans les états mutables. Dans le cas contraire, on peut peux pas poursuivre. Il
a été montré que l&rsquo;analyse à base de polynômes peut être étendue avec des
potentiels pour les états mutables, mais cela est ici hors du champ d&rsquo;étude, qui
est l&rsquo;analyse sur les programmes fonctionnels. RAML peut néanmoins interagir
avec l&rsquo;état mutable pour affiner ses résultat. On peut par exemple, effectuer
une analyse d&rsquo;aliasing sur les références à des fonctions: Si la référence en
question ne peut prendre qu&rsquo;un nombre fini de valeurs (et qu&rsquo;on peut le
détecter), alors on peut calculer un coût au pire pour les appels à travers la
référence. Enfin, on peut étendre l&rsquo;analyse aux programme lançant des exceptions
en annotant le type de l&rsquo;exception et de ses arguments.
</p>
</div>
</div>
</div>

<div id="outline-container-org2222241" class="outline-2">
<h2 id="org2222241">Core RAML, première sémantique</h2>
<div class="outline-text-2" id="text-org2222241">
<p>
Après simplification de l&rsquo;AST OCaml, on se ramène à un langage simple, où les
termes sont sous forme <i>let-share-normale</i>: on a remplacé le plus de
sous-expressions possibles par les variables créées par let ou share (voir
syntaxe). Pour garantir que le programme transformé rend compte de la
consommation du programme en entrée, on peut marquer des constructions comme
<i>gratuites</i> via une meta-syntaxe, qui sont ignorés dans l&rsquo;analyse. On présente
ici un langage réduit, sans types primitifs comme les tableaux, leurs
opérations, ou la conditionelle.
</p>
</div>

<div id="outline-container-org761957e" class="outline-3">
<h3 id="org761957e">Syntaxe</h3>
<div class="outline-text-3" id="text-org761957e">
<ul class="org-ul">
<li>Les classiques:
<ul class="org-ul">
<li>constructeurs, pattern matching</li>
<li>abstraction, application</li>
<li>tuples, références</li>
<li><code>let</code>, <code>let rec</code> de fonctions, variables</li>
</ul></li>
<li><code>fail</code>, pour modéliser les exceptions</li>
<li><code>tick(q ∈ ℚ)</code>, une consommation de ressources</li>
<li><code>share x as (y,z) in …</code>, le partage de valeurs</li>
</ul>

<p>
Les types sont l&rsquo;unité, les tuples, les références, les fonctions et les ADT classiques.
</p>
</div>
</div>

<div id="outline-container-org2cc8f64" class="outline-3">
<h3 id="org2cc8f64">Définitions sémantique</h3>
<div class="outline-text-3" id="text-org2cc8f64">
<p>
Les valeurs \(Val\) sont
</p>
<ul class="org-ul">
<li>\(l\) la position d&rsquo;une valeur sur le tas,</li>
<li>\((l_1, …, l_n)\) les tuples de valeur,</li>
<li>\((λx.e, V)\) les fermetures, avec leurs environnements, et</li>
<li>\(C l\) les applications de constructeur à une valeur.</li>
</ul>

<p>
\(K ∈ Syn\) sont les noeuds de syntaxe, \(S\) est une pile d&rsquo;arguments, et \(M : Syn
× ℕ → ℚ\) est une <i>métrique de ressource</i>. Le paramètre naturel permet, par
exemple, de spécifier la taille des tuples.
</p>

<p>
Le modèle mémoire comporte des variables \(x ∈ Var\) des adresses \(l ∈ Loc\) et les
valeurs \(Val\). Les variables indicent un environnement (partiel) \(V : Var →
Loc\). Enfin le tas est \(H : Loc → Val\) et comporte un pointeur nul avec
\(H(null) = null\).
</p>
</div>
</div>

<div id="outline-container-orgfe7f258" class="outline-3">
<h3 id="orgfe7f258">Sémantique à grand pas</h3>
<div class="outline-text-3" id="text-orgfe7f258">
<p>
Le jugement principal
</p>
<blockquote>
<p>
\(S,V,H  ⊢_Μ e ⇓ w | (q,q')\)
</p>
</blockquote>
<p>
s&rsquo;entend par:
</p>
<ul class="org-ul">
<li>Selon la métrique de ressource \(M\)</li>
<li>dans un environnement \(V\),</li>
<li>avec une pile S et un tas \(H\),</li>
<li>l&rsquo;expression \(e\) se réduit en \(w\),</li>
<li>en induisant un coût \((q,q')\).</li>
</ul>
<p>
En général, on note la consommation \((q, 0)\) par \(q\) et \((0, -q)\) par \(-q\).
</p>

<p>
Les réductions \(w\) sont soit une valeur de retour et un nouvel état \((l,H')\),
soit un blocage \(⊥\), soit une non-terminaison \(○\).
</p>

<p>
Les consommation de ressources sont de la forme \((q,q')\) où \(q\) est la &laquo;&nbsp;marée
haute&nbsp;&raquo;, la quantité maximale de ressource dont on à besoin, et \(q'\) est la
quantité de ressource disponible après l&rsquo;évaluation. La consommation est
paramétrée par la <i>métrique de ressources</i> \(M\), qui est une fonction qui à un
noeud de la syntaxe \(k\) et sa taille \(n\) associe le coût propre de la
construction: \(M(k,n) = (q,q')\).
</p>

<p>
Les consommations forment un monoïde avec \(0 = (0,0)\) et \((q,q')·(p,p') =\)
</p>
<ul class="org-ul">
<li>\((q + p - q', p') \text{ si } q' ≤ p\)</li>
<li>\((q, p' + q' - p) \text{ si } q' > p\)</li>
</ul>

<p>
La composition de deux consommation est alors la consommation de la séquence.
Dans le cas d&rsquo;une analyse de WCET, les consommation sont \((q, 0)\) car on ne peut
pas libérer de temps.  On peut alors dénoter la consommation des structures de données,
par exemple, \((e1,e2)\) a une consommation \(M(\text{tuple},2)·(q1,q1')·(q2,q2')\)
</p>

<p>
Cette sémantique est une version à grands pas de la ZAM, qui est plus proche de
notre système de ressource, et donc facilite les preuves. On ne tient pas compte
des différences entre ZAM et ZAM2, ou entre <i>push-enter</i> et <i>eval-apply</i>. Mais
des métriques appropriées peuvent palier à cela.
</p>
</div>
</div>
</div>

<div id="outline-container-org509632c" class="outline-2">
<h2 id="org509632c">Système de type affine avec pile</h2>
<div class="outline-text-2" id="text-org509632c">
<p>
On introduit les <i>types simples</i>: unité, types numériques, références, tuples,
variables de types (le tout classique), mais aussi <i>fonctions simples</i> et <i>types
inductifs simples</i>:
</p>
</div>

<div id="outline-container-org251e564" class="outline-3">
<h3 id="org251e564">Types des fonctions simple</h3>
<div class="outline-text-3" id="text-org251e564">
<p>
Plutôt que d&rsquo;avoir un type \(t → t\) dans la syntaxe, on a \([t_1…t_n] → t\) qui
spécifie que les \(n\) arguments sont appliqués en même temps. On a donc \(λf,x,y.
f x y : ([T, U] → V) → T → U → V\) mais \(λf,x,y. (f x) y : (T → U → V) → T → U →
V\). On remplacera parfois \([T_1 … T_n]\) par une unique pile \(Σ\) pour les
jugements de typages.
</p>
</div>
</div>

<div id="outline-container-org892fc37" class="outline-3">
<h3 id="org892fc37">Types inductifs simples</h3>
<div class="outline-text-3" id="text-org892fc37">
<p>
Dans un système normal, on défini les types algébriques comme: \(T = ηX.〈C_1:T_1
… C_n:T_n〉\) avec \(X\) liée dans les \(T_i\). Pour prendre en compte la taille
des composantes de type \(X\), il faut en connaître le nombre. Dans notre système
affine, les types inductifs sont: \(T = ηX. 〈C_1:(T_1,k_1) … C_n:(T_n,K_n)〉\),
avec \(X\) non liée dans les \(T_i\). On emballe avec un \(k_{i}\) valeurs de types
\(X\), de sorte à ce que \((T,k) = T×X×…×X\) soit équivalent (dans un sens
homotopique) à sa version classique.
</p>
</div>
</div>

<div id="outline-container-org84873f2" class="outline-3">
<h3 id="org84873f2">Partage et polymorphisme</h3>
<div class="outline-text-3" id="text-org84873f2">
<p>
Le <i>let-polymorphisme</i> consiste à remplacer les valeurs quantifiés par des types
par leur définition durant le typage pour pouvoir instancier sans conflit. Mais
ici ce n&rsquo;est pas une bonne idée: on change la consommation de ressource! RAML ne
supporte que let-polymorphisme des fermetures. Il suffit de les re-définir
autant que nécéssaire, de marquer les copies comme gratuites, et d&rsquo;intancier les
variables de types (maintenant des variables différentes) sans conflit.
</p>
</div>
</div>

<div id="outline-container-org0835a7b" class="outline-3">
<h3 id="org0835a7b">Jugements et dérivations</h3>
<div class="outline-text-3" id="text-org0835a7b">
<p>
Les jugements sont de la forme \(Σ,Γ ⊢ e : T\), avec \(Σ\) une pile de type rendant
compte de l&rsquo;état de la pile de la ZAM durant l&rsquo;évaluation. Ainsi, il existe des
jugements <i>fermés</i> pour lesquels \(Σ = ∅\), qui représentent les jugement des
valeurs elle-mêmes fermés, et de jugements <i>ouvert</i>, présent comme noeuds
internes des dérivations, où \(Σ ≠ ∅\). On a deux théorèmes importants:
</p>

<blockquote>
<p>
Si \(e\) est bien typée, il n&rsquo;existe qu&rsquo;une seule dérivation de \(∅,Γ ⊢ e : T\)
</p>
</blockquote>

<blockquote>
<p>
Pour tout \(Γ, Σ, T\), si \(e\) est bien typée, il y au plus une seule dérivation de
\(Σ,Γ ⊢ e : T\). Alors, on a aussi \(∅,Γ ⊢ e : Σ → T\), et la première dérivation ne
peut apparaître qu&rsquo;en sous-dérivation de la première.
</p>
</blockquote>

<p>
On garantie ces unicités en produisant une règle de typage par règle
d&rsquo;évaluation.
</p>

<p>
On définit \(H \models l ↦ a : A\) signifiant &laquo;&nbsp;Dans le tas \(H\), la position \(l\)
contient une valeur de type \(A\) représentée en mémoire par \(a\)&nbsp;&raquo;. En forme simple,
\(H \models l : A\), et en étendant point-par-point, \(H \models S : Σ\) et \(H
\models V : Γ\) pour les piles et les ensembles de valeurs. On a alors,
</p>

<blockquote>
<p>
Si \(H \models S:Σ,V:Γ\) <br />
et \(Σ;Γ ⊢ e:T\) <br />
et \(S,V,H ⊢_{M} e ⇓ (l,H') | (q,q')\) <br />
alors \(H' \models S:Σ, V:Γ, l:T\)
</p>
</blockquote>


<p>
Ce qui veut dire qu&rsquo;en gros, tout va bien jusqu&rsquo;à maintenant.
</p>
</div>
</div>
</div>

<div id="outline-container-orgb70d2af" class="outline-2">
<h2 id="orgb70d2af">Polynômes de ressources</h2>
<div class="outline-text-2" id="text-orgb70d2af">
</div>
<div id="outline-container-orgda58d15" class="outline-3">
<h3 id="orgda58d15">Polynômes de base</h3>
<div class="outline-text-3" id="text-orgda58d15">
<p>
On veut, pour un type simple, définir les polynômes de base que l&rsquo;on va
combiner. Pour se faire, on interprète les types simple \(T\) en tant qu&rsquo;arbres
\(B_T\). Les, types numériques sont des nombres, les types inductifs des noeuds
internes et le reste des feuilles. Encore une fois, on ignore le coût des
fermetures, que l&rsquo;on a simplifié.
</p>

<p>
On va définir des abstractions en arbres des représentations mémoires dans le
tas. Les arbres \(b ∈ B_T\) d&rsquo;un type inductif simple \(T\) dont les constructeurs
sont \((C_i:(T_i,n_i))_{i≤k}\) sont définis inductivement: les feuilles sont les
types non-inductifs, et les noeuds internes sont \(C_i(a_i, b_1, …, b_{n_i})\)
avec \(a_i ∈ B_{T_i}\) et \(b_j ∈ B_T】\).
</p>

<p>
Pour un arbre \(b ∈ B_T\), on peut considérer une descente dans cet arbre, où l&rsquo;on
ignore ou collecte des étiquettes. Il en résulte une suite finie \(A = (a_m :
T_m)_{m≤k}\). On défini \(τ_B(b)\) l&rsquo;ensemble de ces suites. Muni d&rsquo;une suite \(D =
(D_m)_{m≤k}\) de constructeurs de \(B\), on note \(τ_B(D,b)\) l&rsquo;ensemble des suites
où \(a_i\) est l&rsquo;étiquette d&rsquo;un \(D_i \text{-noeud}\). Armé de \(τ_B(D,b)\), on peut
<i>enfin</i> définir les polynômes de bases.
</p>

<p>
Les <i>polynômes de bases</i> \(P(T)\) d&rsquo;un type simple \(T\) sont un ensemble de
fonction des arbres de \(B_T\) vers les rationnels définis inductivement par:
</p>
<ul class="org-ul">
<li>Pour tout \(T\), \(λa.1 ∈ P(T)\)</li>
<li>Pour \(T = T_1×…×T_n\), si \(p_i ∈ P(T_i)\) alors \(λa_1…a_n. ∏p_i(a_i) ∈ P(T)\)</li>
<li>Pour \(A = (a_m : T_m)_{m≤k}\) résultante d&rsquo;une descente, et</li>
<li>Pour \(T = 〈(C_i:(T_i,n_i)〉\), pour toute suite \(D\) de constructeurs de \(B_T\), on a
\(λb. ∑_{A ∈ τ_B(D,b)} ∏_{m≤k} p_m(a_m)\) dans \(P(T)\) dès que \(∀m, p_m ∈ P(T_m)\).</li>
</ul>

<p>
Les polynômes de base de \(T\) sont indicés par la famille \(I(T)\) définie
inductivement par:
</p>
<ul class="org-ul">
<li>Pour tout \(T\), \(★ ∈ I(T)\)</li>
<li>Pour \(T = T_1×…×T_n\), si \(i_j ∈ I(T_j)\) alors \((i_1, …, i_n) ∈ I(T)\)</li>
<li>Pour \(T\) type inductif de constructeurs \((C_j:(T_j,n_j))_{j≤k}\), toute
séquence \([(C_{j_m}, i_m)]_{m≤k}\) est dans \(I(T)\) dès que \(∀m, i_m ∈ I(T_{j_m})\).</li>
<li>On identifie \(★\), \((★,…,★)\), et \([]\).</li>
</ul>
<p>
On associe naturellement un polynôme de \(p_i ∈ P(T)\) à tout indice de \(i ∈
I(T)\).
</p>
</div>
</div>

<div id="outline-container-orgcec2160" class="outline-3">
<h3 id="orgcec2160">Polynômes de ressources d&rsquo;un type</h3>
<div class="outline-text-3" id="text-orgcec2160">
<p>
Pour un type \(T\), les polynômes de ressources \(∑q_i•p_i\) sont les combinaisons
linéaires (de support fini) à facteurs rationnels de polynômes de base indicés
par \(I(T)\). Ils sont ainsi représentes par les séquences \((q_i)_{i∈I}\). On
notera qu&rsquo;ils sont croissants en chacun de leurs composantes, et on note \(R(T)\)
l&rsquo;ensemble des polynômes, et \(Q(T)\) l&rsquo;ensemble de leurs réprésentations.
</p>

<p>
Le degré d&rsquo;un polynôme de ressource est au plus celui d&rsquo;un de ses polynôme de
base, qui lui-même est calculable depuis son indice. On peut alors limiter
l&rsquo;espace de recherche de l&rsquo;analyse en limitant les indices. <i>RAML</i> par exemple
impose les indices tels que les polynômes de ressources inférés soient de degrés
au plus \(K\), une constante définie par l&rsquo;utilisateur.
</p>

<p>
Enfin, il sera bon de noter que deux indices peuvent dénoter le même polynôme de
base, ce qui ne blesse pas la correction de l&rsquo;analyse, et que certains indices
peuvent représenter des polynômes nuls. Ces derniers peuvent être détectés et
éliminés par leurs indices simplement.
</p>
</div>
</div>

<div id="outline-container-org5d84025" class="outline-3">
<h3 id="org5d84025">Potentiel d&rsquo;un programme</h3>
<div class="outline-text-3" id="text-org5d84025">
<p>
On va annoter les types simple avec des polynômes de ressources. A partir de
maintenant, \(T\) réfère au type et \(|T|\) à sa version simple, sans annotation, et
ce inductivement. On peut spécifier les consommation des fonctions \(f : T_f =
[A_1, …, A_n] → B\) par des annotations \(Θ\) qui sont des ensemble de paires
\((Q_A,Q_B)\) avec \(Q_A ∈ Q(|A_1×…×A_n|)\) et \(Q_B ∈ Q(|B|)\). Dans les types, on
a donc $f : 〈T<sub>f</sub>, Θ〉. On nomme <i>type annoté</i> une paire \((A,Q)\) d&rsquo;un type \(A\)
et d&rsquo;un polynôme de ressource de \(Q(|A|)\).
</p>

<p>
On peut alors définir le <i>potentiel</i> d&rsquo;une valeur \(v\) d&rsquo;un tas \(H\). Si pour \(v\),
\(H \models l → a : |A|\), et que \(v : (A, Q)\), son potentiel est
</p>

<p>
\[ Φ_H(v : (A,Q)) = ∑q_i•p_i(a)  \]
</p>

<p>
On étends point-à-point ce potentiel aux contextes et pile, en les entendant
comme un produit cartésien des indices de leurs éléments. On note \(I(Σ;Γ)\) les
indices d&rsquo;un contexte, et un <i>contexte annoté</i> est simplement \(Σ;Γ;Q\). On
définit le potentiel de l&rsquo;état d&rsquo;un programme comme tel:
</p>

<p>
Soit \(H\) un tas, \(S\) une pile et \(V\) en environnement tels que \(H \models V : Γ,
S:Σ\). On déconstruit \(Γ = x_1 : A_1, …, x_n : A_n\) avec \(H \models V(x_j) ↦
a_j : |A_j|\), et \(S = l_1, …, l_m\) avec \(H \models l_k ↦ b_k : |B_k|\). Le
potentiel est la combinaison linéaire sur \(I(Σ,Γ)\)
</p>

<p>
\[
    Φ_{S,V,H}(Σ;Γ;Q) = ∑ q_i•∏p_j(a_j) ∏p_k(b_k)
\]
</p>
</div>
</div>
</div>
<div id="outline-container-org87285a5" class="outline-2">
<h2 id="org87285a5">Typage de ressources</h2>
<div class="outline-text-2" id="text-org87285a5">
<p>
Les règles de typages sont un médium peu adapté à la communication des calculs
d&rsquo;annotations que l&rsquo;on présente dans cette partie. On choisi de les omettre. On
présente néanmoins les opérations définis pour établir les jugements de type annotés.
</p>
</div>

<div id="outline-container-org2600b9c" class="outline-3">
<h3 id="org2600b9c">(Dé)-construction des termes</h3>
<div class="outline-text-3" id="text-org2600b9c">
<p>
On considère ici la transformation des potentiels issus de la
construction/destruction d&rsquo;un \(x : B = ηX.〈…, C : (A,n),…〉\). Si le
constructeur de \(x\) est \(C\), et que \(y : A×B^{n}\) (avec \(B^{n}\) les
\(n\text{-uplets}\) de \(B\)), alors \(x\) et \(y\) sont équivalents et l&rsquo;on passe de
l&rsquo;un à l&rsquo;autre lors de l&rsquo;application de \(C\) ou d&rsquo;un filtrage par motif.Pour
préciser les changements d&rsquo;annotations que cet isomorphisme induit, on définit
le \(C\text{-dépliage}\) d&rsquo;annotations de potentiels.
</p>

<p>
On pose \(Σ\) et \(Γ,x:B\) le contexte exécution <i>plié</i> et \(Q\) son annotation, et
\(Γ' = Γ,y:A×B^{n}\) l&rsquo;environnement <i>déplié</i>. L&rsquo;annotation associée à \(Σ;Γ'\) est
notée \(◁_B^{C}(Q)\), et est définie afin de conserver le potentiel total entre
les deux contextes d&rsquo;évaluation. On peut heureusement définir ce dépliage par
contraintes linéaires.
</p>
</div>
</div>

<div id="outline-container-orgb0bf9d4" class="outline-3">
<h3 id="orgb0bf9d4">Partage</h3>
<div class="outline-text-3" id="text-orgb0bf9d4">
<p>
Comme nous utilisons le partage, il nous faut aussi pouvoir combiner les
annotations que \(x_1:A\) et \(x_2:A\) quand elles sont le résultat de <code>let share x
as (x_{1}, x_{2}) in</code>. On prendra soin de remarquer que les usages de <code>x_1</code> et
<code>x_2</code> ne sont en général pas symétriques, et qu&rsquo;il faut donc coefficienter
correctement les participations de <code>x_1</code> et <code>x_2</code> au potentiel de <code>x</code> dans
l&rsquo;annotation de la forme <code>let share</code> et de ses sur-formes. Encore une fois, ces
coefficients sont décrits par contraintes linéaires. Si \(Q\) est l&rsquo;annotation
sous le <code>let share</code>, on note \(\curlyveedownarrow Q\) au dessus.
</p>

<p>
Si vous regardez ce document eu format HTML, l&rsquo;opérateur ne rendra pas
correctement. Il s&rsquo;agit d&rsquo;une flèche vers le bas, avec deux branches en guise de
corps, l&rsquo;une courbant vers la gauche, et l&rsquo;autre vers la droite
</p>
</div>
</div>

<div id="outline-container-org4ade613" class="outline-3">
<h3 id="org4ade613">Sous-typage</h3>
<div class="outline-text-3" id="text-org4ade613">
<p>
On définit le sous-typage structurel classique sur les types annotés, avec pour
les fonctions, la condition qu&rsquo;un type \(A → B, Θ\) est sous-type de \(A' → B', Θ'\)
si \(A'\) est un sous-type de \(A\), \(B\) en est un de \(B'\) et \(Θ' ⊂ Θ\).
</p>
</div>
</div>

<div id="outline-container-org18387ac" class="outline-3">
<h3 id="org18387ac">Jugement</h3>
<div class="outline-text-3" id="text-org18387ac">
<p>
Le jugement du système de ressourece est \(Σ;Γ;Q ⊢_{M} e : (A, Q')\) s&rsquo;entendant
comme &laquo;&nbsp;Selon la métrique de ressourec \(M\), dans un contexte d&rsquo;évaluation \(Σ;Γ\)
(distingués pour leurs coûts) annotés par \(Q\), si on a disposition au moins
\(Φ(Σ;Γ;Q)\) de potentiel, alors l&rsquo;expression \(e\) a le type \(|A|\), et soit elle
diverge, soit elle produit une valeur \(v\), et dans ce cas le potentiel restant
est d&rsquo;au moins \(Φ(v : (A,Q'))\)&nbsp;&raquo;.
</p>

<p>
On introduit la métrique \(\text{cf}\) de coût nul pour les constantes, purement
utilitaire, qui intervient dans la règle <i>LET</i>.
</p>
</div>
</div>

<div id="outline-container-org3971182" class="outline-3">
<h3 id="org3971182">Règles</h3>
<div class="outline-text-3" id="text-org3971182">
<p>
<i>C&rsquo;est un gros morceau, qui est certainement plus clair en algorithme qu&rsquo;en
code. On le passe pour le moment.</i>
</p>
</div>
</div>

<div id="outline-container-orgc63fb02" class="outline-3">
<h3 id="orgc63fb02">Théorème: Cohérence</h3>
<div class="outline-text-3" id="text-orgc63fb02">
<p>
Si \(H \models V:Γ, S:Σ\) et \(Σ,Γ,Q ⊢_{M} e : (B,Q')\):
</p>
<ol class="org-ol">
<li>alors \(S,V,H ⊢_{M} e ⇓ w | (p,p')\) et \(p ≤ Φ_{S,V,H}(Σ,Γ,Q)\),</li>
<li>et si, de plus \(w = (l,H')\):
<ol class="org-ol">
<li>\(H \models l : B\),</li>
<li>et \(p-p' ≤ Φ_{S,V,H}(Σ,Γ,Q) - Φ_{H'}(l : (B,Q'))\)</li>
</ol></li>
</ol>

<p>
Preuve par double induction: sur le jugement de réduction, et au delà dans le
jugement de typage.
</p>
</div>
</div>
</div>
</div>
</body>
</html>
