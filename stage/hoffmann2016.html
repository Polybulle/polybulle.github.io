<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-04-06 Mon 18:40 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Notes de Lecture: Towards Automatic Resource Bound Analysis for OCaml</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Hector Suzanne" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="https://gongzhitaao.org/orgcss/org.css"/>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.cacheClassElem = elem.className;
         elem.cacheClassTarget = target.className;
         target.className = "code-highlighted";
         elem.className   = "code-highlighted";
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(elem.cacheClassElem)
         elem.className = elem.cacheClassElem;
       if(elem.cacheClassTarget)
         target.className = elem.cacheClassTarget;
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title">Notes de Lecture: Towards Automatic Resource Bound Analysis for OCaml</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgdba2bde">1. Introduction</a></li>
<li><a href="#org01000f3">2. Survol</a></li>
<li><a href="#org841e12b">3. Analyse de la programmation fonctionnelle</a>
<ul>
<li>
<ul>
<li><a href="#org2f46677">3.0.1. Fermetures et curryfication</a></li>
<li><a href="#org97c2f76">3.0.2. Gestion de l&rsquo;ordre supérieur</a></li>
<li><a href="#org75615d0">3.0.3. Effets de bord</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org2246bd5">4. Limites</a></li>
<li><a href="#org45fb675">5. Typage</a>
<ul>
<li><a href="#org2895e3b">5.1. Core RAML</a>
<ul>
<li><a href="#orgd038cd1">5.1.1. Syntaxe</a></li>
<li><a href="#org26cbfd9">5.1.2. Définitons préalables</a></li>
<li><a href="#org4b83cba">5.1.3. Valeurs</a></li>
<li><a href="#orge9e9925">5.1.4. Sémantique à grand pas</a></li>
</ul>
</li>
<li><a href="#orgc480b82">5.2. Consommation de ressource</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgdba2bde" class="outline-2">
<h2 id="orgdba2bde"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
Contribution : une analyse statique de
ressources pour les programmes OCaml <i>fonctionnels</i>, <i>d&rsquo;ordre supérieur</i>, <i>avec
polymorphisme et type utilisateurs</i>. On obtient des polynômes multivariables
décrivant l&rsquo;usage de ressources tel que le WCET, l&rsquo;occupation mémoire ou la
consommation d&rsquo;énergie. On utilise <b>AARA : Automatic Amortized Resource
Analysis</b>, un npuveau système de type et une nouvelle sémantique de la machine
virtuelle <i>ZINC</i> d&rsquo;OCaml.
On peut trouver des bornes asymptotique fortes pour des programmes
réels, comme les utilitaires standard sur les listes, l&rsquo;algorithme de Dijkstra,
ou un client pour Amazon DynamoDB avec analyse statique du coût des accès au
nuage.
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">type</span> <span style="color: #9a7500;">('a, 'b) ablist</span> =
| <span style="color: #2a2a2a; background-color: #eeeeee;">Acons</span> <span style="color: #3b6ea8;">of</span> 'a * ('a, 'b) list
| <span style="color: #2a2a2a; background-color: #eeeeee;">Bcons</span> <span style="color: #3b6ea8;">of</span> 'b * ('a, 'b) list
| <span style="color: #2a2a2a; background-color: #eeeeee;">ABNil</span>

<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #29838d;">sort_the_as</span> <span style="color: #cb9aad;">ablist</span> = <span style="color: #3b6ea8;">match</span> ablist <span style="color: #3b6ea8;">with</span>
| <span style="color: #2a2a2a; background-color: #eeeeee;">Acons</span> (a, tail) -&gt; <span style="color: #2a2a2a; background-color: #eeeeee;">Acons</span> (quicksort a, sort_the_as tail)
| <span style="color: #2a2a2a; background-color: #eeeeee;">Bcons</span> (b, tail) -&gt; <span style="color: #2a2a2a; background-color: #eeeeee;">Bcons</span> (b          , sort_the_as tail)
| <span style="color: #2a2a2a; background-color: #eeeeee;">ABNil</span> -&gt; <span style="color: #2a2a2a; background-color: #eeeeee;">ABNil</span>

<span style="color: #b1b1b1;">(*</span>
<span style="color: #b1b1b1;">  RAML detecte les bornes suivantes:</span>
<span style="color: #b1b1b1;">    N = nombre de noeuds Acons de `ablist`</span>
<span style="color: #b1b1b1;">    K = max des tailles des arguments 'a des Acons</span>
<span style="color: #b1b1b1;">    L = N+K = taille de `ablist`</span>
<span style="color: #b1b1b1;">    Cout de sort_the_as:</span>
<span style="color: #b1b1b1;">      13*K*N^2 + 22*K*N + 13*L + 15*N + 11</span>

<span style="color: #b1b1b1;">  On retrouve bien la borne asymptotique en O(K^2 * N)</span>
<span style="color: #b1b1b1;">*)</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org01000f3" class="outline-2">
<h2 id="org01000f3"><span class="section-number-2">2</span> Survol</h2>
<div class="outline-text-2" id="text-2">
<p>
On extrait un AST typé du compilateur OCaml, puis on infère de nouveaux types
contenant des information de potentiel pour chaque expression. D&rsquo;une déclaration
<code>t : T</code>, on obtient une autre définition <code>t : (T'; &lt;qi...&gt;))</code> ou <code>T'</code> est proche
de <code>T</code> (on précise les applications partielle/totales des fonctions aux sites
d&rsquo;appels), et les <code>qi</code> sont des coefficients permettant de définir un potentiel
φ(t) = Σ qi * pi(t). Les polynômes <code>pi</code> sont définis pour chaque constructeurs
du type <code>T</code>. La sémantique du langage hôte induit des contraintes linéaires
entre les potentiels. Elles sont résolues par un solveur de programmation
linéaire externe lors d&rsquo;un parcours de l&rsquo;AST, comme on infère les types dans un
programme en produisant et résolvant des contraintes d&rsquo;unification.
</p>
</div>
</div>

<div id="outline-container-org841e12b" class="outline-2">
<h2 id="org841e12b"><span class="section-number-2">3</span> Analyse de la programmation fonctionnelle</h2>
<div class="outline-text-2" id="text-3">
<p>
Il y a trois principale difficultés: Les fermeture/l&rsquo;application partielle,
les arguments d&rsquo;ordre supérieurs, et les effets de bords
</p>
</div>
<div id="outline-container-org2f46677" class="outline-4">
<h4 id="org2f46677"><span class="section-number-4">3.0.1</span> Fermetures et curryfication</h4>
<div class="outline-text-4" id="text-3-0-1">
<p>
On prend comme exemple <code>val append : 'a list -&gt; 'a list -&gt; 'a list</code> de la
bibliothèque standard. L&rsquo;appel <code>let foo = append xs</code> termine en temps constant,
et ne fait que créer une fermeture. Par contre, l&rsquo;appel suivant <code>foo ys</code> renvoie
la liste <code>xs ++ ys</code> en temps et espace O(xs). Donc, l&rsquo;usage de ressource de
<code>foo</code> ne dépend pas de son argument <code>ys</code>, mais est linéaire en la taille de la
valeur capturée <code>xs</code>. Hélas, il n&rsquo;est pas suffisant de dé-curryfier <code>append</code>
pour retomber sur un cas plus simple: Un appel à <code>append</code> nécessite d&rsquo;allouer
une paire pour les deux arguments. Dans le cas normal (<code>append</code> est curryfiée),
on prduit une fermeture si l&rsquo;application est partielle, ou on appelle <code>append</code>
sans allocation si les deux arguments sont fournis.
</p>

<p>
On résout ce problème en raffinant les types des fonctions sur leurs sites
d&rsquo;appels. Les applications partielles peuvent être saturées par eta-expansion,
et on change le type de la fonction de <code>a1 -&gt; ... -&gt; an -&gt; t</code> en <code>[a1 ... an] -&gt;
t</code>, qui indique la saturation de l&rsquo;appel. L&rsquo;analyse rend compte de
l&rsquo;usage correct des ressource pour le second type, mais pas pour le premier.
En effet, l&rsquo;algorithme est bien plus complexe si les valeurs capturées
dans les fermetures interviennent dans le calcul de complexité. L&rsquo;analyse est
guidée par ce principe: <i>La complexité d&rsquo;un appel de fonction ne doit dépendre
que de la taille de ses arguments</i>
</p>

<p>
On reconnaît la possibilité d&rsquo;étendre le système pour gérer ces cas, mais cela a
un coût important de compléxité de l&rsquo;analyse. On pourrait par exemple étendre le
raffinement des types avec des types dépendants.
</p>
</div>
</div>
<div id="outline-container-org97c2f76" class="outline-4">
<h4 id="org97c2f76"><span class="section-number-4">3.0.2</span> Gestion de l&rsquo;ordre supérieur</h4>
<div class="outline-text-4" id="text-3-0-2">
<p>
Dans le cas plus simple où on se limite à des estimations linéaires du coût, il est
possible de calculer la consommation de ressource en présence d&rsquo;arguments
d&rsquo;ordre supérieur en se ramenant à l&rsquo;ordre 1. Mais c&rsquo;est seulement possible quand les arguments sont analysables, et on doit entrelacer le typage et la génération de
contraintes. On préfère séparer les deux processus.
</p>

<p>
On peut alors analyser des fonctions même en l&rsquo;absence d&rsquo;information sur les
arguments: Il suffit de supposer leurs coût négligeable. L&rsquo;analyse n&rsquo;est alors
pas veine: On peut déterminer le coût propre de fonctions comme <code>map</code> et <code>fold</code>,
et l&rsquo;analyse sert de preuve de terminaison. On peut en effet dire qu&rsquo;une
fonction ayant un coût défini termine si et seulement si les appels aux
arguments terminent tous.
</p>

<p>
Dans les cas où la terminaison de la fonction dépend de propriétés des arguments
d&rsquo;ordre supérieur, on ne peut pas conclure dans le cas général. Mais on peut
reprendre l&rsquo;analyse dans les sites d&rsquo;appels où ces arguments sont connus !
exemple:
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #b1b1b1;">(* </span><span style="color: #b1b1b1;">Impossible de conclure ici </span><span style="color: #b1b1b1;">*)</span>
<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #29838d;">iter</span> <span style="color: #cb9aad;">f</span> <span style="color: #cb9aad;">x</span> = <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #cb9aad;">y</span> = f x <span style="color: #000000; font-weight: bold;">in</span> <span style="color: #3b6ea8;">if</span> y = <span style="color: #97365b; font-weight: bold;">0</span> <span style="color: #3b6ea8;">then</span> () <span style="color: #3b6ea8;">else</span> iter f y

<span style="color: #b1b1b1;">(* </span><span style="color: #b1b1b1;">mais ici on peut sp&#233;cialiser pour une valeur pr&#233;sice de `f`</span><span style="color: #b1b1b1;">*)</span>
<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #29838d;">foo</span> <span style="color: #cb9aad;">x</span> = iter (<span style="color: #3b6ea8;">fun</span> <span style="color: #cb9aad;">z</span> -&gt; <span style="color: #97365b; font-weight: bold;">0</span>) x
</pre>
</div>
</div>
</div>

<div id="outline-container-org75615d0" class="outline-4">
<h4 id="org75615d0"><span class="section-number-4">3.0.3</span> Effets de bord</h4>
<div class="outline-text-4" id="text-3-0-3">
<p>
L&rsquo;analyse vérifie que le coût du programme est indépendant des valeurs stockées
dans un état mutable quelconque. Dans le cas contraire, on peut peux pas
poursuivre. Il a été montré que l&rsquo;analyse à base de polynômes peut être étendu
avec des potentiels pour les états mutables, mais le projet ne le fait pas, pour se
focaliser sur la contribution principale, l&rsquo;analyse sur les programmes
fonctionnels.
L&rsquo;analyse peut néanmoins interagir avec l&rsquo;état mutable pour affiner ses
résultat. On peut par exemple, effectuer une analyse d&rsquo;aliasing sur les
références à des fonctions: Si la référence en question ne peut prendre qu&rsquo;un
nombre fini de valeurs (et qu&rsquo;on peut le détecter,) alors on peut calculer un
coût au pire pour les appels à travers la référence.
Enfin, on peut étendre l&rsquo;analyse aux programme lançant des exceptions en
annotant le type de l&rsquo;exception et de ses arguments.
</p>
</div>
</div>
</div>
<div id="outline-container-org2246bd5" class="outline-2">
<h2 id="org2246bd5"><span class="section-number-2">4</span> Limites</h2>
<div class="outline-text-2" id="text-4">
<p>
Ne sont pas supportés:
</p>
<ul class="org-ul">
<li>Les modules et les foncteurs</li>
<li>Les enregistrements</li>
<li>la POO d&rsquo;OCaml</li>
<li>la FFI</li>
<li>le pattern matching imbriqué</li>
<li>les arguments optionnels</li>
<li>les structures mutables dans le cas général</li>
<li>Les try/with en cas d&rsquo;exception lancée</li>
</ul>
</div>
</div>
<div id="outline-container-org45fb675" class="outline-2">
<h2 id="org45fb675"><span class="section-number-2">5</span> Typage</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-org2895e3b" class="outline-3">
<h3 id="org2895e3b"><span class="section-number-3">5.1</span> Core RAML</h3>
<div class="outline-text-3" id="text-5-1">
<p>
Après simplification de l&rsquo;AST OCaml, on se ramène à un langage simple, où les
termes sont sous forme <i>let-share-normale</i>, ou l&rsquo;on a remplacé le plus de sous
expressions possibles par les variables créées par let ou share (voir syntaxe).
Pour garantir que le programme transformé rend compte de la consommation du
programme en entrée, on peut marquer des constructions comme <i>gratuites</i>
(meta-syntaxe). Les constructions gratuites sont ignorés dans l&rsquo;analyse. On
présente ici un langage réduit, sans types primitifs comme les tableaux, leurs
opérations, ou conditionelle.
</p>
</div>
<div id="outline-container-orgd038cd1" class="outline-4">
<h4 id="orgd038cd1"><span class="section-number-4">5.1.1</span> Syntaxe</h4>
<div class="outline-text-4" id="text-5-1-1">
<dl class="org-dl">
<dt>Les classiques</dt><dd>variables, application n-aire, abstraction, constructeurs,
tuples, références, let, let rec de fonctions, pattern matching</dd>
<dt>fail</dt><dd>pour modéliser les exceptions</dd>
<dt>tick(q ∈ ℚ)</dt><dd>consommation de ressources</dd>
<dt>share x as (y,z) in</dt><dd>partage de valeurs</dd>
</dl>
</div>
</div>
<div id="outline-container-org26cbfd9" class="outline-4">
<h4 id="org26cbfd9"><span class="section-number-4">5.1.2</span> Définitons préalables</h4>
<div class="outline-text-4" id="text-5-1-2">
<dl class="org-dl">
<dt>K ∈ Syn</dt><dd>les neouds de syntaxe</dd>
<dt>M : Syn × ℕ -&gt; ℚ</dt><dd>Une <i>métrique de ressource</i></dd>
<dt>x ∈ Var</dt><dd>les variables</dd>
<dt>l ∈ Loc</dt><dd>les adresses du tas</dd>
<dt>H : Loc -&gt; Val</dt><dd>Un tas, de support fini</dd>
<dt>V : Var -&gt; Loc</dt><dd>Un environnement, partiel</dd>
<dt>S = · | l : S</dt><dd>Une pile d&rsquo;arguments</dd>
<dt>null ∈ dom(H)</dt><dd>Un pointeur nul tel que H(null) = null</dd>
</dl>
</div>
</div>
<div id="outline-container-org4b83cba" class="outline-4">
<h4 id="org4b83cba"><span class="section-number-4">5.1.3</span> Valeurs</h4>
<div class="outline-text-4" id="text-5-1-3">
<dl class="org-dl">
<dt>l</dt><dd>position d&rsquo;une valeur sur le tas</dd>
<dt>(l1, &#x2026;, ln)</dt><dd>tuples de valeur</dd>
<dt>(λx.e, V)</dt><dd>Fermeture (avec son jus)</dd>
<dt>C l</dt><dd>Application de constructeur à une valeur</dd>
</dl>
</div>
</div>
<div id="outline-container-orge9e9925" class="outline-4">
<h4 id="orge9e9925"><span class="section-number-4">5.1.4</span> Sémantique à grand pas</h4>
<div class="outline-text-4" id="text-5-1-4">
<p>
Le jugement de la sémantique est
</p>
<pre class="example">
S,V,H  ⊢_Μ e ⇓ w | (q,q')
</pre>
<p>
qui s&rsquo;entend par: Dans un environnement V, avec une pile S et un tas H,
l&rsquo;expression e se réduit en un nombre d&rsquo;étape en w, en induisant un coût (q,q&rsquo;)
selon la métrique de ressource M. Les réductions w sont soit
</p>
<dl class="org-dl">
<dt>(l, H&rsquo;)</dt><dd>Une valeur de retour et un nouvel état</dd>
<dt>⊥</dt><dd>Echec (exceptions, accès de tableau invalide&#x2026;)</dd>
<dt>○</dt><dd>Non-terminaison</dd>
</dl>
</div>
</div>
</div>
<div id="outline-container-orgc480b82" class="outline-3">
<h3 id="orgc480b82"><span class="section-number-3">5.2</span> Consommation de ressource</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Les consommation de ressources sont de la forme (q,q&rsquo;) où q est la &ldquo;marée
haute&rdquo;, la quantité maximale de ressource dont on à besoin, et q&rsquo; est la quantité
de ressource disponible après l&rsquo;évaluation. La consommation est paramétrée par
une <i>métrique de ressources</i> M, qui est une fonction qui à un noeud de la
syntaxe k et sa taille n associe un coût propre de la construction M(k,n) =
(q,q&rsquo;). Les consommations forment un monoïde avec
</p>
<ul class="org-ul">
<li>0 = (0,0)</li>
<li>(q,q&rsquo;)·(p,p&rsquo;) =
<ul class="org-ul">
<li>(q + p - q&rsquo;, p&rsquo;) si q&rsquo; ≤ p</li>
<li>(q, p&rsquo; + q&rsquo; - p) si q&rsquo; &gt; p</li>
</ul></li>
</ul>
<p>
La composition de deux consommation est la consommation de la séquence.
Dans le cas d&rsquo;une analyse de WCET, les consommation sont (q, 0) car on le libère
pas de temps. En général, on note la consommation (q, 0) par q et (0, -q) par
-q. On peut alors dénoter la consommation des structures de données, par
exemple:
</p>

<p>
(e1,e2) a une consommation M(tuple,2)·(q1,q1&rsquo;)·(q2,q2&rsquo;)
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Hector Suzanne</p>
<p class="date">Created: 2020-04-06 Mon 18:40</p>
</div>
</body>
</html>
